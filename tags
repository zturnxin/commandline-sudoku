!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BACKTRACKSOLVE_H	backtracksolve.h	2;"	d
BUFSIZE	stack.c	4;"	d	file:
CFLAGS	Makefile	/^CFLAGS:=-Wall -g$/;"	m
CHECK_H	check.h	2;"	d
COUNT_LINE_H	countlines.h	2;"	d
DISP_H	disp.h	2;"	d
FILL_H	fill.h	2;"	d
GENERATE_H	generate.h	2;"	d
LOAD_H	load.h	2;"	d
STACK_H	stack.h	2;"	d
ZONE_H	zone.h	2;"	d
backtrack_mode	backtracksolve.c	/^static unsigned long long backtrack_mode;$/;"	v	file:
backtracksolve	backtracksolve.c	/^void backtracksolve(void) $/;"	f
board	backtracksolve.c	/^static int board[9][9];$/;"	v	file:
board_solution	backtracksolve.c	/^int board_solution[9][9];$/;"	v
box	zone.c	/^int box[9];$/;"	v
buftos	zone.c	/^int buftos(int puzzle[][9])$/;"	f
col	stack.h	/^	int col;$/;"	m	struct:grid
col	zone.c	/^int col[9];$/;"	v
condidates	zone.c	/^int condidates[9][9][9+1];$/;"	v
count_condidate	backtracksolve.c	/^inline int count_condidate(int r, int c, int *flag)$/;"	f
disp	disp.c	/^void disp(int puzzle[][9])$/;"	f
dispcond_all	disp.c	/^void dispcond_all()$/;"	f
dispcond_box	disp.c	/^void dispcond_box(int b)$/;"	f
dispcond_col	disp.c	/^void dispcond_col(int c)$/;"	f
dispcond_grid	disp.c	/^void dispcond_grid(int r, int c)$/;"	f
dispcond_line	disp.c	/^void dispcond_line(int r)$/;"	f
dispcond_unique	disp.c	/^void dispcond_unique()$/;"	f
empty_stack	stack.c	/^void empty_stack(void)$/;"	f
empty_sudoku_buf	zone.c	/^void empty_sudoku_buf(void)$/;"	f
exception_buf	backtracksolve.c	/^static sigjmp_buf exception_buf;$/;"	v	file:
exist_error	check.c	/^int exist_error(int puzzle[][9])$/;"	f
fill_grid	fill.c	/^int fill_grid(int puzzle[][9], int r, int c, int n)$/;"	f
fill_unique	fill.c	/^void fill_unique(int puzzle[][9])$/;"	f
generate	generate.c	/^int generate(int b[][9], int max_filled, int full[][9])$/;"	f
generate_full	generate.c	/^void generate_full(int puzzle[][9])$/;"	f
get_condidates	zone.c	/^void get_condidates(int cond[][9][9+1], int puzzle[][9])$/;"	f
getbox	zone.c	/^void getbox(int puzzle[][9], int r, int c)$/;"	f
getcol	zone.c	/^void getcol(int puzzle[][9], int r, int c)$/;"	f
getrow	zone.c	/^void getrow(int puzzle[][9], int r, int c)$/;"	f
grid	stack.h	/^struct grid $/;"	s
init_condidates	zone.c	/^void init_condidates(int cond[][9][9+1])$/;"	f
init_sudoku	zone.c	/^void init_sudoku(int puzzle[][9])$/;"	f
is_empty	stack.c	/^int is_empty(void)$/;"	f
is_filled	check.c	/^int is_filled(int puzzle[][9], int r, int c)$/;"	f
is_finished	check.c	/^int is_finished(int puzzle[][9])$/;"	f
is_full	stack.c	/^int is_full(void)$/;"	f
is_unique	check.c	/^int is_unique(int r, int c, int puzzle[][9])$/;"	f
load	load.c	/^void load(char *filename, int lines)$/;"	f
main	sudoku.c	/^int main(void)$/;"	f
maxlines	countlines.c	/^int maxlines(char *fn) $/;"	f
menu	disp.c	/^void menu(void)$/;"	f
num	stack.h	/^	int num;$/;"	m	struct:grid
osudoku	zone.c	/^int osudoku[9][9];$/;"	v
pgrid	stack.h	/^typedef struct grid *pgrid;$/;"	t	typeref:struct:grid
pop	stack.c	/^struct grid pop(void)$/;"	f
push	stack.c	/^void push(struct grid g)$/;"	f
randindex	generate.c	/^inline void randindex(int index[])$/;"	f
reset	fill.c	/^void reset(int puzzle[][9])$/;"	f
row	stack.h	/^	int row;$/;"	m	struct:grid
row	zone.c	/^int row[9];$/;"	v
same_sudoku	zone.c	/^int same_sudoku(int p[][9], int q[][9])$/;"	f
sbuf_full	zone.c	/^int sbuf_full(void)$/;"	f
sbufsize	zone.c	/^static int sbufsize;$/;"	v	file:
solutions	backtracksolve.c	/^static unsigned long long solutions;$/;"	v	file:
stack	stack.c	/^static struct grid stack[BUFSIZE];$/;"	v	typeref:struct:grid	file:
stobuf	zone.c	/^int stobuf(int puzzle[][9])$/;"	f
sudoku	zone.c	/^int sudoku[9][9];$/;"	v
sudoku_and	zone.c	/^void sudoku_and(int p[][9], int q[][9])$/;"	f
sudoku_buf_size	zone.c	/^int sudoku_buf_size(void)$/;"	f
sudoku_copy	zone.c	/^void sudoku_copy(int p[][9], int q[][9])$/;"	f
sudoku_solve	backtracksolve.c	/^unsigned long long sudoku_solve(int puzzle[][9], unsigned long long mode)$/;"	f
sudoku_swap	zone.c	/^void sudoku_swap(int p[][9], int q[][9])$/;"	f
sudokubuf	zone.c	/^static char sudokubuf[1024][81];$/;"	v	file:
swap	generate.c	/^inline void swap(int *a, int *b)$/;"	f
tmp	sudoku.c	/^int tmp[2][9][9];$/;"	v
tmpdisp	disp.c	/^void tmpdisp(void)$/;"	f
top	stack.c	/^static int top = 0;$/;"	v	file:
unfill	fill.c	/^void unfill(void)$/;"	f
